/* DO NOT EDIT THIS FILE - it is machine generated */
#include <amysa_mobileproject_alar_alar_OpenCVNativeClass.h>


const int MIN_CONTOUR_AREA = 100;
int question = 0;
int rows = 0;
Mat croppedTest;
int responseQuestions = 0;
vector <int> answerStudent;
vector <Mat>  options;
vector <int> answers = {'A','B','C','D','E'} ;

JNIEXPORT jint JNICALL Java_amysa_mobileproject_alar_alar_OpenCVNativeClass_convertGray
        (JNIEnv *, jclass, jlong addrRgba, jlong addrGray ){
    Mat& mRgb = *(Mat *)addrRgba;
    Mat& mGray = *(Mat*)addrGray;

    int conv;
    jint retVal;
    conv = toGray(mRgb,mGray);

    retVal = (jint)conv;
    return retVal;

}


JNIEXPORT jint JNICALL Java_amysa_mobileproject_alar_alar_OpenCVNativeClass_getAnswer
        (JNIEnv *, jclass,jint index){

    int value = answerStudent[index];
    jint data = (jint)value;
    return data;
}

JNIEXPORT jint JNICALL Java_amysa_mobileproject_alar_alar_OpenCVNativeClass_loadImages
        (JNIEnv *, jclass,jlong address,jlong address_A,jlong address_B,jlong address_C,jlong address_D,jlong address_E){



    Mat& test = *(Mat *)address;
    Mat& A = *(Mat *)address_A;
    Mat& B = *(Mat *)address_B;
    Mat& C = *(Mat *)address_C;
    Mat& D = *(Mat *)address_D;
    Mat& E = *(Mat *)address_E;

    options.push_back(A);
    options.push_back(B);
    options.push_back(C);
    options.push_back(D);
    options.push_back(E);

    jint resulVal;
    int result;
    result = load(test);
    resulVal = (jint)result;
    return  resulVal;


  }

int toGray(Mat img,Mat&gray){




    line( img, Point(0, 100 ), Point( img.cols, 100), Scalar( 110, 220, 0 ),  10, 8 );

    line( img, Point(50,0), Point( 50, img.rows), Scalar( 110, 220, 0 ),  10, 8 );

    line( img, Point(img.cols, 100 ), Point( img.cols, 100), Scalar( 110, 220, 0 ),  10, 8 );


    if (gray.rows == img.rows && gray.cols == img.cols){
        return 1;
    }
    return 0;
}


    int load(Mat test){
        Rect crop(30,70,1027,test.rows-200);
        croppedTest = test(crop);


        question = countQuestion(croppedTest);

        croppedTest = test(crop);

        question = question / 5;
        rows = question / 6;
        int rest = question % 6;

        if ( rest > 0){
            rows = rows +1;
        }



        getAnwersGroup();

        return question;

    }


void getAnwersGroup(){
    int add =0;
    for (int i=0;i<rows;i++){
        Rect crop(15,add,1001,croppedTest.rows-180);
        Mat group  = croppedTest(crop);
        getAnswer(group,add);
        add = add + 28;

    }
}

void getAnswer(Mat group,int add){
    int inicio = 12;
    Mat letter;
    vector<int>sizes = {0,30,59,89,114};
    for (int i=0;i<6;i++){
        vector<int>imagesPixels = {0,0,0,0,0};
        Rect crop (inicio,add,145,27);
        Mat answer = croppedTest(crop);
        inicio = inicio + 172;

        if (responseQuestions!=question){
            responseQuestions++;
            int letter_area = 0;
            for (int i=0;i<5;i++){
                Rect area(sizes[i],0,31,27);
                letter = answer(area);
                Mat option = options[i];
                int result = compareImages(letter,option);
                imagesPixels[i] = result;
            }


            int answerMark;
            int minimum = 0;
            for (int i = 1;i<5;i++){
                if (imagesPixels[minimum]>imagesPixels[i]){
                    minimum = i;
                }
            }

            answerMark = answers[minimum];
            answerStudent.push_back(answerMark);


        }
    }
}





    int countQuestion(Mat actualImage){

        int intChar;
        int count=1;

        Mat imgTrainingNumbers;
        Mat imgGrayscale;
        Mat imgBlurred;
        Mat imgThresh;
        Mat imgThreshCopy;

        vector<vector<Point> > ptContours;
        vector<Vec4i> v4iHierarchy;

        cv::Mat matClassificationInts;
        cv::Mat matTrainingImagesAsFlattenedFloats;

        imgTrainingNumbers = actualImage;


        cvtColor(imgTrainingNumbers, imgGrayscale, CV_BGR2GRAY);

        GaussianBlur(imgGrayscale,imgBlurred,cv::Size(5, 5),0);


        adaptiveThreshold(imgBlurred,imgThresh,255,cv::ADAPTIVE_THRESH_GAUSSIAN_C,cv::THRESH_BINARY_INV,11,2);

        imgThreshCopy = imgThresh.clone();

        findContours(imgThreshCopy,ptContours,v4iHierarchy,cv::RETR_EXTERNAL,cv::CHAIN_APPROX_SIMPLE);


        for (int i = 0; i < ptContours.size(); i++) {
            if (contourArea(ptContours[i]) > MIN_CONTOUR_AREA) {
                Rect boundingRect = cv::boundingRect(ptContours[i]);
                rectangle(imgTrainingNumbers, boundingRect, cv::Scalar(0, 0, 255), 2);
                Mat matROI = actualImage(boundingRect);
                count ++;
            }

        }


        return  count;

    }

int compareImages(Mat base,Mat test1){
    int c =0;
    Mat result;
    compare(base,test1,result,cv::CMP_EQ);
    for(int y = 0; y < result.rows; y++)
    {
        for(int x = 0; x < result.cols; x++)
        {
            if (result.at<int>(x,y) != 0){
                c++;
            }

        }
    }

    return c;

}